# -*- coding: utf-8 -*-
"""B19200_DSC_A3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t360MDt5hu9J9EyFGpL3yRGEy76syPa5

Data science 3  Group 4  Lab 3
 Name - Tushika Singh
 Roll no. - B19200
 Mobile NO. - 9444854202
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# reading csv file
from google.colab import files
from sklearn.decomposition import PCA
uploaded = files.upload()
import io
df = pd.read_csv(io.BytesIO(uploaded['landslide_data3_8754e0f12c730296821e7d3f6341f71e.csv']))

# Dataset is now stored in a Pandas Dataframe.
# My code may defer a little because I wrote my codes on Google colab.

df.drop(['dates','stationid'],axis=1,inplace=True)

#1
print('Question 1:')
n=0 #Initializing attribute count as 0
for i in df.columns:
    bottom_whis=2.5*np.percentile(df[i],25)-1.5*np.percentile(df[i],75) #Q1-1.5*IQR
    upper_whis=2.5*np.percentile(df[i],75)-1.5*np.percentile(df[i],25)  #Q3+1.5*IQR
    outliers=df[i][(df[i]<bottom_whis) | (df[i]>upper_whis)] #Dataframe of outliers in df[i]
    df.iloc[outliers.index,n]=(df[i].drop(outliers.index)).median() #Replacing outliers with median of remaning values of df[i]
    n+=1 #Incrementing attribute count

    #a
print('a)')
df_a=df.copy() #Copying df
def Min_Max():#Function for computing Minimum and Maximum
    min_max=pd.concat((df_a.min(),df_a.max()),axis=1) #Dataframe with min and max of Df
    min_max=min_max.T
    index=pd.Series(['Min','Max'])
    min_max.set_index([index],inplace=True) #Setting Index
    min_max=min_max.T
    print(min_max)
print('\nBefore Min_Max Normalization:')
Min_Max() #Function call

df_a=(df-df.min())/(df.max()-df.min())*(9-3)+3 #Min_Max Normalization
print('\nAfter Min_Max Normalization:')
Min_Max() #Function call

#b
print('\nb)')
df_b=df.copy() #Copying df
def Standardization(): #Function for computing Mean and Standard Deviation 
    mean_std=pd.concat((round(df_b.mean(),6),df_b.std()),axis=1)#Dataframe with Mean and Std Dev of Df
    mean_std=mean_std.T
    index=pd.Series(['Mean','Standard Dev'])
    mean_std.set_index([index],inplace=True) #Setting Index
    mean_std=mean_std.T
    print(mean_std)
print('\nBefore Standardization:')
Standardization()#Function call

df_b=(df-df.mean())/(df.std())
print('\nAfter Standardization:')
Standardization()#Function call

print('\nQuestion 2:')
print('\nQuestion 2:')
mean=np.array([0,0])
cov=np.array([[5,10],[10,13]])
D=np.random.multivariate_normal(mean,cov,1000,'ignore') #Generating Data

#a
print('a)')
plt.figure(figsize=(6,6))
plt.scatter(D.T[0],D.T[1],marker='x',color='blue')
plt.xlim(-15,15);plt.ylim(-15,15)
plt.xlabel('x1');plt.ylabel('x2')
plt.title('Plot of 2D synthetic data');plt.show()
#b
print('\nb)')
eigval,eigvec=np.linalg.eig(np.cov(D.T)) #Eigen Value and Eigen Vector
print('Eigen values:',*eigval,'\nEigen vectors:',*eigvec.T)
plt.figure(figsize=(6,6))
plt.scatter(D.T[0],D.T[1],marker='x',color='blue')
plt.quiver([0],[0],eigvec[0][0],eigvec[1][0],angles="xy",color='red',scale=6)
plt.quiver([0],[0],eigvec[0][1],eigvec[1][1],angles="xy",color='red',scale=3)
plt.xlim(-15,15);plt.ylim(-15,15)
plt.xlabel('x1');plt.ylabel('x2')
plt.title('Plot of 2D synthetic data and Eigen vectors');plt.show()

#c
print('\nc)')
prj=np.dot(D,eigvec) #Projection 

plt.figure(figsize=(6,6))
plt.scatter(D.T[0],D.T[1],marker='x',color='blue')
plt.quiver([0],[0],eigvec[0][0],eigvec[1][0],angles="xy",color='red',scale=6)
plt.quiver([0],[0],eigvec[0][1],eigvec[1][1],angles="xy",color='red',scale=3)
plt.scatter(prj[:,0]*eigvec[0][0],prj[:,0]*eigvec[1][0],color='magenta',marker='x')
plt.xlabel('x1');plt.ylabel('x2')
plt.xlim(-15,15);plt.ylim(-15,15)
plt.title('Projected values on 1st eigen vector');plt.show()

plt.figure(figsize=(6,6))
plt.scatter(D.T[0],D.T[1],marker='x',color='blue')
plt.quiver([0],[0],eigvec[0][0],eigvec[1][0],angles="xy",color='red',scale=6)
plt.quiver([0],[0],eigvec[0][1],eigvec[1][1],angles="xy",color='red',scale=3)
plt.scatter(prj[:,1]*eigvec[0][1],prj[:,1]*eigvec[1][1],color='magenta',marker='x')
plt.xlabel('x1');plt.ylabel('x2')
plt.xlim(-15,15);plt.ylim(-15,15)
plt.title('Projected values on 2nd eigen vector');plt.show()

#d
print('\nd)')
D_=np.dot(prj,eigvec.T) #Reconstructing Reduced Dimensional Data
print('Root Mean Square Error:',(((D-D_)**2).sum()/len(D_)))

print('\nQuestion 3:')
df=df_b #Replacing df with standardized df

#a
print('a)')
eigval,eigvec=np.linalg.eig(np.cov(df.T))#Eigen Value and Eigen Vector
eigval.sort()#Sorting Eigen Values in Ascending Order
eigval=eigval[::-1]#Reversing (In Descending Order)

pca=PCA(n_components=2)#PCA with l=2
Data=pca.fit_transform(df)


for i in range(2):
    print('Variance along Eigen Vector',i+1,':',np.var(Data.T[i]),
          '\nEigen Value corresponding to Eigen Vector',i+1,':',eigval[i],'\n')

plt.scatter(Data.T[0],Data.T[1])# Scatter plot of reduced dimensional data.
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.title('Scatter plot of reduced dimensional data');plt.show()

#b
print('\nb)')
plt.bar(range(1,8),eigval)#Plot
plt.scatter(range(1,8),eigval)
plt.plot(range(1,8),eigval)
plt.xlabel('Index');plt.ylabel('Eigen Value')
plt.title('Eigen Values in Descending Order');plt.show()


#c
print('c)')
RMSE=[]#Empty List
for i in range(1,8):
    pca=PCA(n_components=i)# PCA with l=i
    Data=pca.fit_transform(df)#Data with Reduced Dimension
    D_=pca.inverse_transform(Data)#Reconstructed Data
    RMSE.append((((df.values-D_)**2).sum()/len(D_))**.5)#Appending list with RMSE
    
plt.bar(range(1,8),RMSE,color='orange')#Plot
plt.plot(range(1,8),RMSE,color='black')
plt.scatter(range(1,8),RMSE)
plt.ylabel('RMSE');plt.xlabel('l')
plt.title('Reconstruction Error');plt.show()